#+title:  Object  Implementation of Mini Version of User Directory Application
#+AUTHOR: VLEAD
#+DATE: [2016-05-18 Wed]
#+PROPERTY: results output
#+PROPERTY: exports code
#+SETUPFILE: ../../org-templates/level-2.org
#+options: ^:nil
#+LATEX: Literal LaTeX code for export
* Introduction

In the object implementation of the mini version of the User
Directory Application, all entities are Objects.  In
addition, there is an object called =System= that holds the
state of the application (=user-set=, =session-set=, etc.).

Each of the entities of the data model are implemented as
objects.  Each entity is defined via a class definition, a
constructor and getter and setter methods that access and
mutate the fields of the entity. 

The main idea in the object model is that certain relations
of the data model (those that are total functions) are
implemented as /fields/.  For example the =User= object has
a field called =email= that holds an object of type =Email=.

As a start, we do not implement all relations of the data
model.  For example, the relation =user: Email > User?= is
not implemented.  It should be, if we desire to have an
implementation that is /complete/ with respect to the data
model.  Which elements of the data model are implemented and
which are not are decisions based on the end user
requirements of the application.

* Entities


** Name

Elements of the entity type =Name= are built by invoking the
constructor =Name(value)=.  =value= needs to be an
alphabetic string.

#+begin_src python
class Name():
    pass

ValueClassTemplate.populate_class(Name, is_alphabetic_string)

class Email():
    pass

ValueClassTemplate.populate_class(Email, is_email_str)





#+end_src
#+NAME: class_Name
#+BEGIN_SRC python
class Name(object):
    value = None
    def __init__(self, value):
        # value: String
        if is_alphabetic_string(value):
            self.value = value
        else:
            raise TypeError('%s is not a Name!' % value)

    def __str__(self):
        return self.value

  
#+END_SRC

*** Test the Construction
#+NAME: class_TestName
#+BEGIN_SRC python 
class TestName(TestCase):
    TESTING = True
    def test_name_type(self):
        print "test_name_type"
        new_name = Name("John")
        # correct name
        self.assertEqual(new_name.value, "John")
        # incorrect name
        self.assertRaises(TypeError, Name, "123dasd")
#+END_SRC

** Email
     Email is a type as defined in RFC [[https://tools.ietf.org/html/rfc5321][5321]], [[https://tools.ietf.org/html/rfc5322][5322]] and [[https://tools.ietf.org/html/rfc6531][6531]].
     Following is the constructor for this class.

#+NAME: class_Email
#+BEGIN_SRC python
class Email(object):
    value = None
    def __init__(self, value):
        if not is_email_str(value):
            raise TypeError('%s is not an email!' % value)
        self.value = value

    def __str__(self):
        return self.value

    def __eq__(self, other):
        if isinstance(other, self.__class__):
            return self.value == other.value
        else:
            return False
#+END_SRC

*** Test the Construction
#+NAME: class_TestEmail
#+BEGIN_SRC python 
class TestEmail(TestCase):
    TESTING = True
    def test_email_type(self):
        print "test_email_type"
        new_email = Email("smith@gmail.com")
        # correct name
        self.assertEqual(new_email.value, "smith@gmail.com")
        # incorrect name
        self.assertRaises(TypeError, Email, "@@@@smithgmail.com")
#+END_SRC

** User
*** Fields
The =User= object has three fields, 

     + =name: Name=    (mutable)
     + =email: Email=  (mutable)
     + =role: Role=

#+NAME: class_User
#+BEGIN_SRC python
class User():
    name= None
    email = None
    role = None
#+END_SRC

*** Constructor

    A =User= is constructed as follows:

    #+BEGIN_EXAMPLE
    usr = User(<object of Name>, <object of Email>, <object of Role>)
    #+END_EXAMPLE

#+NAME: init_User
#+BEGIN_SRC python
    def __init__(self, name, email, role):
        self.set_email(email)
        self.set_name(name)
        self._set_role(role)
#+END_SRC
**** Test the constructor
 #+NAME: class_TestUser
 #+BEGIN_SRC python 
class TestUser(TestCase):
    TESTING = True

    def setUp(self):
        setup()

    def tearDown(self):
        tearDown()

    def test_user_creation_with_role(self):
        print "test_user_creation_with_role"
        user = User(Name("Robin Smith"), 
                    Email("smith@gmail.com"),
                    Role.admin)
        self.assertEqual(user.role, Role.admin)
        self.assertEqual(user.email.value, "smith@gmail.com")

    def test_user_creation_with_wrong_type(self):
        print "test_user_creation_with_wrong_type"
        with self.assertRaises(TypeError):
            user = User(Name("Robin@ Smith"), #invalid name
                    Email("smith@gmail.com"),
                    Role.admin)
 #+END_SRC


*** Setters and Getters
**** =set_name=
#+NAME: user_set_name
#+BEGIN_SRC python
    def set_name(self, name):
        if not isinstance(name, Name):
            raise TypeError('`name` argument should be of type Name.')
        else:
            self.name = name
#+END_SRC


**** =set_email=
#+NAME: user_set_email
#+BEGIN_SRC python 
    def set_email(self, email):
        if not isinstance(email, Email):
            raise TypeError('`email` argument should be of type Email.')
        else:
            self.email = email

#+END_SRC


***** Test
#+NAME: test_set_email_of_user
#+BEGIN_SRC python 
    def test_set_email_of_user(self):
        print "test_set_email_of_user"
        user = User(Name("Robin Smith"), 
                Email("smith@gmail.com"),
                Role.admin)
        user.set_email(Email("smith1@gmail.com"));
        self.assertEqual(user.email, "smith1@gmail.com")
#+END_SRC


**** =_set_role=

Note that =_set_role= is not part of the public interface of
=User=.  It is used only to initialize a =User= object. 

#+NAME: user_set_role 
#+BEGIN_SRC python 
    def _set_role(self, role):
        if not isinstance(role, Role):
            raise TypeError('`role` argument should be of type Role.')
        else:
            self.role = role
#+END_SRC


**** =get_role=
#+NAME:  user_get_role
#+BEGIN_SRC python 
    def get_role(self):
        return self.role
#+END_SRC


**** =get_email=
 #+NAME:  user_get_email
 #+BEGIN_SRC python
    def get_email(self):
        return self.email
 #+END_SRC


**** =get_name=
#+NAME:  user_get_name
#+BEGIN_SRC python
    def get_name(self):
        return self.name
#+END_SRC

**** =to_client=

This is a debugging method that returns the object's fields
as a dictionary.
#+NAME: user_to_client
#+BEGIN_SRC python 
    def to_client(self):
        return {
            'name': self.name.value,
            'email': self.email.value,
            'role': self.role.to_client()
        }
#+END_SRC

** Role

   =Role= is an enumerated type with two variants: =admin=
   and =user=.   

*** Definition
#+NAME: class_Role
#+BEGIN_SRC python
class Role():
    name = None
    admin = None
    user = None

    def __init__(self, name):
        self.name = name

    def __str__(self):
        return self.name

    def to_client(self):
        return {
            'role': self.name
        }
Role.admin = Role("admin")
Role.user  = Role("user")
#+END_SRC

** Session
    A session holds a user.
#+NAME: class_Session
#+BEGIN_SRC python
class Session():
    user = None
#+END_SRC

*** Constructor
    The signature of the Session constructor is:
    #+BEGIN_EXAMPLE
    session = Session(<Object of type User>)
    #+END_EXAMPLE

#+NAME: init_Session
#+BEGIN_SRC python
    def __init__(self, user):
        self._set_user(user)
#+END_SRC


**** Test Constructor
#+NAME: class_TestSession
#+BEGIN_SRC python
class TestSession(TestCase):
    TESTING = True

    def setUp(self):
        setup()

    def tearDown(self):
        tearDown()

    def test_session_creation(self):
        print "test_session_creation"
        user = User(Name("Robin Smith"), 
                    Email("smith@gmail.com"),
                    Role.user)
        session = Session(user)
        self.assertEqual(session.user.role.name, "user")
#+END_SRC

*** Setters and Getters
**** =get_user=
#+NAME: session_get_user
#+BEGIN_SRC python
    def get_user(self):
        return self.user
#+END_SRC

**** =_set_user=
Note that =_set_user= is used internally by the 
=Session= constructor.

#+NAME: session_set_user
#+BEGIN_SRC python
    def _set_user(self, user):
        if not isinstance(user, User):
            raise TypeError('`user` argument should be of type User.')
        else:
            self.user = user
#+END_SRC

**** =to_client=
#+NAME: session_to_client
#+BEGIN_SRC python
    def to_client(self):
        return {
            'session': self.user.to_client()
        }
#+END_SRC
** Custom Exceptions
   These are some of the custom exceptions used in the application.
*** AttributeRequired

#+name: class_AttributeRequired
#+BEGIN_SRC python
class AttributeRequired(Exception):
    str = None

    def __init__(self, str):
        self.str = str

    def __str__(self):
        return repr(self.str)

#+END_SRC

*** Constraint Error
#+name: class_ConstraintError
#+BEGIN_SRC python
class ConstraintError(Exception):
    str = None

    def __init__(self, str):
        self.str = str

    def __str__(self):
        return repr(self.str)

#+END_SRC

*** NotAuthorized Error
#+name: class_NotAuthorizedError
#+BEGIN_SRC python
class NotAuthorizedError(Exception):
    str = None

    def __init__(self, str):
        self.str = str

    def __str__(self):
        return repr(self.str)

#+END_SRC


* initialization
** Imports for Python API
#+name: imports_for_obj
#+BEGIN_SRC python
# -*- coding: utf-8 -*-
from op_exceptions import AttributeRequired
from op_exceptions import ConstraintError
from op_exceptions import NotAuthorizedError
from utils import *
#+END_SRC


** Imports and Initialization of testcases for Python API

#+name: imports_for_test_obj
#+BEGIN_SRC python
# -*- coding: utf-8 -*-
import unittest
from unittest import TestCase
from datetime import datetime

from src.obj import *
from src.op_exceptions import AttributeRequired
from src.op_exceptions import ConstraintError
from src.op_exceptions import NotAuthorizedError

#+END_SRC


** Imports for utility functions

#+NAME: imports_for_utils
#+BEGIN_SRC python

# module to hold all utilities/helper functions

import json

import re


#+END_SRC



* Run Test Cases
#+NAME: run_test_cases
#+BEGIN_SRC python
def setup():
    user = User(Name("admin user"),
                Email("admin-user@gmail.com"),
                Role.admin)
      
def tearDown():
    pass

if __name__ == '__main__':
    unittest.main()
#+END_SRC

* Tangling
** =src/=
*** =__init__.py=
#+BEGIN_SRC python :tangle ../../src/__init__.py :eval no :noweb yes
import obj
#+end_src
*** =obj.py=
#+BEGIN_SRC python :tangle ../../src/obj.py :eval no :noweb yes
<<imports_for_obj>>
<<class_Name>>
<<class_Email>>
<<class_User>>
<<init_User>>
<<user_set_name>>
<<user_set_email>>
<<user_set_role>>
<<user_get_role>>
<<user_get_email>>
<<user_get_name>>
<<user_to_client>>
<<class_Role>>
<<class_Session>>
<<init_Session>>
<<session_set_user>>
<<session_get_user>>
<<session_to_client>>
#+END_SRC

*** =op-exceptions.py=
#+BEGIN_SRC python :tangle ../../src/op_exceptions.py :eval no :noweb yes
<<class_AttributeRequired>>
<<class_ConstraintError>>
<<class_NotAuthorizedError>>
#+end_src
*** =utils.py=
#+BEGIN_SRC python :tangle ../../src/utils.py :eval no :noweb yes
<<imports_for_utils>>
<<def_check_pred>>
<<def_check_inst>>
<<def_is_alphabetic_str>>
<<def_is_email_str>>
#+end_src
** =tests/=
*** =__init__.py=
#+BEGIN_SRC python :tangle ../../tests/__init__.py :eval no :noweb yes
print "tests"
#+end_src
*** =test_obj.py=
#+BEGIN_SRC python :tangle ../../tests/test_obj.py :eval no :noweb yes
<<imports_for_test_obj>>
<<class_TestName>>
<<class_TestEmail>>
<<class_TestUser>>
<<test_set_email_of_user>>
<<class_TestSession>>
<<class_Test_is_alphabetic_str>>
<<def_test_three>>
<<run_test_cases>>
#+END_SRC

*** =test_utils.py=
#+begin_src python :tangle ../../tests/test_utils.py :eval no :noweb yes

#+end_src
