#+title:  Entities
#+SETUPFILE: ../../../org-templates/level-0.org
#+TAGS: boilerplate(b)
#+EXCLUDE_TAGS: boilerplate
* Introduction

In the object implementation of the mini version of the User
Directory Application, all entities are Objects.  In
addition, there is an object called =System= that holds the
state of the application (=user-set=, =session-set=, etc.).

Each of the entities of the data model are implemented as
objects.  Each entity is defined via a class definition, a
constructor and getter and setter methods that access and
mutate the fields of the entity. 

The main idea in the object model is that certain relations
of the data model (those that are total functions) are
implemented as /fields/.  For example the =User= object has
a field called =email= that holds an object of type =Email=.

As a start, we do not implement all relations of the data
model.  For example, the relation =user: Email > User?= is
not implemented.  It should be, if we desire to have an
implementation that is /complete/ with respect to the data
model.  Which elements of the data model are implemented and
which are not are decisions based on the end user
requirements of the application.

* Name
=Name= is a value class with type =is_alphabetic_str=.
#+NAME: class_Name
#+begin_src python
from impl.objects.utils import *

Name = ValueClassTemplate.mk_class("Name", is_alphabetic_str)
is_Name = is_inst(Name)
check_Name = check_pred(is_Name)
#+end_src
* Email
=Name= is a value class with type =is_email_str=.
#+NAME: class_Email
#+begin_src python
Email = ValueClassTemplate.mk_class("Email", is_email_str)
is_Email = is_inst(Email)
check_Email = check_pred(is_Email)
#+end_src

* Role
   =Role= is an enumerated type with two variants: =admin=
   and =user=.   

#+NAME: class_Role
#+BEGIN_SRC python
class Role():
    name = None
    admin = None
    user = None

    def __init__(self, name):
        self.name = name

    def __str__(self):
        return self.name

    def to_client(self):
        return {
            'role': self.name
        }
Role.admin = Role("admin")
Role.user  = Role("user")
is_Role = lambda arg: arg in [Role.admin, Role.user]
#+END_SRC

* User
A =User= entity has =Name=, =Email= and =Role= fields.

#+NAME: class_User
#+BEGIN_SRC python
User = ClassTemplate.mk_class(name=is_Name, 
                              email=is_Email, 
                              role=is_Role)

User.__eq__ = lambda self, other: \
                  isinstance(other, self.__class__) and \
                  self.email == other.email

is_User = is_inst(User)
check_User = check_pred(is_User)
#+END_SRC

* Session
    A session holds a user.
#+NAME: class_Session
#+BEGIN_SRC python
Session = ClassTemplate.mk_class(user=is_User)

is_Session = is_inst(Session)
check_Session = check_pred(is_Session)
#+END_SRC

* Tests
#+NAME: class_TestEntities
#+BEGIN_SRC python 
class TestEntities(TestCase):
    TESTING = True

    def test_entities(self):
        n1 = Name("ravi")
        n2 = Name("ravi")

        u1 = User(name=n1, email=e1, role=Role.admin)
        u2 = User(name=n2, email=e1, role=Role.user)
        s1 = Session(user=u1)
        s2 = Session(user=u2)

        print "test_name_type"
        new_name = Name("John")
        # correct name
        self.assertEqual(new_name.value, "John")
        # incorrect name
        self.assertRaises(TypeError, Name, "123dasd")
#+END_SRC

* Infra 														:boilerplate:
** sources
*** Imports 
#+name: imports_for_sources
#+BEGIN_SRC python
# -*- coding: utf-8 -*-
import unittest
from unittest import TestCase
from datetime import datetime
from ..util.class_templates import *
#+end_src

** Tests
*** Imports 
#+name: imports_for_tests
#+BEGIN_SRC python
# -*- coding: utf-8 -*-
import unittest
from unittest import TestCase
from datetime import datetime
from ..utils.class_templates import *
from class_templates import *
#+end_src
*** Running tests
#+NAME: run_test_cases
#+BEGIN_SRC python
if __name__ == '__main__':
    unittest.main()
#+END_SRC

* Tangling														:boilerplate:
** sources
#+BEGIN_SRC python :tangle entities.py :eval no :noweb yes
<<imports_for_sources>>
<<class_Name>>
<<class_Email>>
<<class_Role>>
<<class_User>>
<<class_Session>>
#+end_src
** tests
#+BEGIN_SRC python :tangle test_entities.py :eval no :noweb yes
<<imports_for_tests>>
<<class_TestEntities>>
<<run_test_cases>>
#+end_src


